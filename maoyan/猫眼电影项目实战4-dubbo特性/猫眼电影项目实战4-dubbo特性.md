# 猫眼电影项目实战4-dubbo特性

## 启动检查

* 服务启动过程中验证服务提供者的可用性，但是这种特性不是适用于所有业务
* 验证过程中出现问题，则阻止spring容器初始化
* 服务启动检查可以尽可能早的发现服务问题

要想取消，就找到所有引用的地方，改为：

```
@Reference(IntefaceClass=UserAPi.class,check=false)
```

此时，没有依赖，那么我调用这个接口会怎么样呢？

实验证明，虽然可用启动成功，但是会报服务异常，因为没有可用的服务提供者。对于大多数情况下，不要这样配置。一旦业务应用非常大时，很有可能会忘记启动某些服务。

## 负载均衡


策略名称 | 策略描述
---|---
Random | 随机，按权重设置随机概率
RoundRobin | 轮询，按公约后的权重设置轮询比率
LeastActive | 最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差
ConsistentHash | 一致性hash，相同参数的请求总是发到同一个提供者

对于`Random`,在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。

对于`RoundRobin`，存在慢的提供者累积请求的问题，比如某一台服务器比较慢，请求卡在这一台服务器上。

对于`LeastActive`,使慢的提供者收到更少请求，因为越慢的提供者的调用前后奇数差越大


配置：

* 服务端服务级别


```properties
<dubbo:service interface="..." loadbalance="roundrobin" />
```

* 客户端服务级别


```properties
<dubbo:reference interface="..." loadbalance="roundrobin" />
```

* 服务端方法级别


```properties
<dubbo:service interface="...">
    <dubbo:method name="..." loadbalance="roundrobin"/>
</dubbo:service>
```

* 客户端方法级别


```properties
<dubbo:reference interface="...">
    <dubbo:method name="..." loadbalance="roundrobin"/>
</dubbo:reference>
```

一般场景下，配置服务端的负载均衡。

## 多协议支持

对于我们之前在配置文件中的关于dubbo的一个配置:


```peoperties
spring:
    dubbo:
        server: true
        registry: zookeeper://localhost:2181
        protocol:
            name: dubbo
            port: 20881
```

这里的protocol是指我们这里用的通信协议，dubbo是协议的名称，port是通信的端口号。

* dubbo支持多种协议
* 最常见的协议是dubbo协议（dubbo可以适应多种协议，典型的是dubbo协议，底层基于TCP协议而封装）
* dubbo并不是所有场景都使用的，dubbo的数据包不能太大，官方建议是大概在100k以下
* 多消费者对应一个服务提供者时可以用，在可以支撑的情况下，多个消费者去跟一个服务提供者建立长连接，充分发挥带宽优势

> 因dubbo协议采用单一长连接，
假设网络为千兆网卡(1024Mbit=128MByte)，
根据测试经验数据每条连接最多只能压满7MByte(不同的环境可能不一样，供参考)，
理论上1个服务提供者需要20个服务消费者才能压满网卡。

特性对比 | dubbo | RMI | Hessian
---|--- | --- | --- 
连接数 | 单连接 | 多连接 | 多连接
连接方式 | 长连接 | 短连接 | 短连接
传输协议 | TCP协议 | TCP协议 | Http协议
传输方式 | NIO异步传输 | 同步传输 | 同步传输
适用场景 | 数据包较小，消费者个数多，常规方式 | 数据包大小不一，消费者和提供者数量相差不大 | 数据包大小不一，消费者和提供者数量相差不大


* 为什么采用异步单一长连接：

因为服务的现状大都是服务提供者少，通常只有几台机器，而服务的消费者多，可能整个网站都在访问该服务，比如Morgan的提供者只有6台提供者，却有上百台消费者，每天有1.5亿次调用。


如果采用常规的hessian服务，服务提供者很容易就被压跨，通过单一连接，保证单一消费者不会压死提供者，长连接，减少连接握手验证等，并使用异步IO，复用线程池，防止C10K问题。

这里的单一连接，就是说，消费者和提供者之间建立一根管道，所有的消息传输都只通过这根管道即可。长连接会大量减少不必要的重复的握手回收动作。异步IO可能最大程度地复用线程池，并且不会阻塞。

因为是单一的长连接，加上是NIO，如果单个数据包很大，那么在固定的带宽下，这个数据包的处理就会很慢，会严重拉低数据的处理速度。

所有这种模式使得dubbo适用于频繁的小数据量的消息的传输。